Disgard, the definite Usgard disassembler
=========================================

Changelog
---------

Updates since the previous version released on ticalc.org on 28 March 2005
* this file

Updates since the first version
* unknown instructions now output .db $xx as they should
* added the -o, -j and -a options
* plus some minor fixes.

Prologue
--------

I myself had been working on a TI-85 assembly game for a while, when suddenly the Redmond team demostrated to me once again their competence. The NTFS of my C drive unexpectedly collapsed, and with it went the source of my game. Luckily, I 
did have a fairly recent development version of it saved on my calc, and that was what I was forced to resort to. I gathered all the calc software again that I had had, and started browsing ticalc.org for Z80 disassemblers. I found a few, but none of those gave satisfying results; I would not have had the stamina to follow through restoring the source from the results given by any one of them. So I had no other options than to give up development on my game, or to make a more intelligent decompiler myself. Naturally I chose the latter thing to do, and this program is the outcome.
 
Inner structure
---------------
If anyone is interested in how the program works, there are four phases, with the following tasks:

1. The program begins at the "main" block and searches through it until it finds a ret or unconditional jump instruction.
  * Doing this, it collects all word-size arguments and treats them either as symbols, immediate values or, if there is relocation placed on the argument (or in -n mode, if it simply fits the address space), labels that are then inserted into a special table.
  * Each newly labeled code block is then in turn searched through in the same fashion, until they have all been processed.
  * Command-line -c/-d declarations are also handled here (-d causes the end of a code block).

2. In this phase all seemingly  "misaligned" labels (i.e. that point into the middle of an instruction) are marked in a special way for the next phase to  handle them.
  * Also a new data label is generated pointing to such an instruction (these are what you will see as xx_ins_xx labels).

3. This phase generates names for all labels (numerates them in order).
  * All misaligned labels marked in phase 2 are given a name Pxx_ins_xx+x, but you will only see them where used in instructions.

4. The last phase does all the visible work.
  * It prints out everything according to the info generated by the previous phases, e.g. .orgs, labels, data and instructions. 

Notes
-----
The program will not read more than 1000 instructions from the table file. Otherwise only the amount of memory will limit the maximum size of programs (well, the 28k is also kind of a limit :).

The original version of this program was compiled into Dos protected-mode with DJGPP, Dj Delorie's Dos port of the Gnu C, with the help of a program called RHIDE. The source should be portable to other environments as well [and has in fact been backported to Gnu C here].

Finally, as an example for the confused reader, here's how I disassemble Usgard itself:

Usage example
-------------

disgard prgm/usgstd.85s usgstd.asm -o8bfc/0 -d8c02 -c8c09 -d8c3c -c8c41 -d8cda -c90ad -j -n -s0 -l -f
